use std::ffi::CStr;

use libwcdb_sys::CPPHandleStatement;

use crate::{
    error::{self, Result, WCDBError},
    utils::cpp_bridged,
    winq::statement::Statement,
};

use super::{database::Database, prepared::PreparedStatement};

pub struct Handle {
    raw: libwcdb_sys::CPPHandle,
    database: Database,
    owned: bool,
}

impl Handle {
    pub fn owned(raw: libwcdb_sys::CPPHandle, database: Database) -> Self {
        Self {
            raw,
            database,
            owned: true,
        }
    }

    pub fn reference(raw: libwcdb_sys::CPPHandle, database: Database) -> Self {
        Self {
            raw,
            database,
            owned: false,
        }
    }

    pub fn as_ptr(&self) -> libwcdb_sys::CPPHandle {
        self.raw
    }

    pub fn as_db_ptr(&self) -> libwcdb_sys::CPPDatabase {
        self.database.as_ptr()
    }
}

impl Drop for Handle {
    fn drop(&mut self) {
        if self.owned {
            unsafe {
                libwcdb_sys::WCDBReleaseCPPObject(self.raw.into());
            }
        }
    }
}

impl Handle {
    /// Execute a Winq statement directly.
    ///
    /// - Parameter statement: the statement to execute.
    pub fn exec(&self, stmt: &dyn Statement) -> Result<()> {
        let executed = unsafe { libwcdb_sys::WCDBHandleExecute(self.as_ptr(), stmt.raw_stmt()) };
        if !executed {
            return Err(self.error());
        }
        Ok(())
    }

    /// Execute a raw SQL statement directly.
    pub fn exec_sql(&self, sql: &CStr) -> Result<()> {
        let sql = sql.as_ptr();
        let executed = unsafe { libwcdb_sys::WCDBHandleExecuteSQL(self.as_ptr(), sql) };
        if !executed {
            return Err(self.error());
        }
        Ok(())
    }

    /// Use `sqlite3_prepare` internally to prepare a new statement,
    /// and wrap the `sqlite3_stmt` generated by `sqlite3_prepare` into `PreparedStatement` to return.
    ///
    /// If the statement has been prepared by this method before, and you have not used `-[WCTHandle finalizeAllStatements]` to finalize it,
    /// then you can use this method to regain the previously generated `sqlite3_stmt`.
    ///
    /// This method is designed for the situation where you need to use multiple statements at the same time to do complex database operations.
    /// You can prepare a new statement without finalizing the previous statements, so that you can save the time of analyzing SQL syntax.
    ///
    /// If you only need to use one statement, or you no longer need to use the previous statements when you use a new statement,
    /// it is recommended to use `exec(_:)` or `prepare(_:)`.
    ///
    /// - Parameter statement: the statement to prepare.
    /// - Throws: `Error`
    pub fn get_or_create_prepared_stmt(&self, stmt: &dyn Statement) -> Result<PreparedStatement> {
        let prepared = unsafe {
            libwcdb_sys::WCDBHandleGetOrCreatePreparedStatement(self.as_ptr(), stmt.raw_stmt())
        };
        let valid = unsafe { libwcdb_sys::WCDBHandleStatementCheckPrepared(prepared) };
        if !valid {
            return Err(self.error());
        }
        Ok(prepared.into())
    }

    /// Use `sqlite3_finalize` to finalize all `sqlite3_stmt` generate by current handle.
    pub fn finalize_all_stmt(&self) {
        unsafe {
            libwcdb_sys::WCDBHandleFinalizeStatements(self.as_ptr());
        }
    }

    /// The wrapper of `sqlite3_changes`.
    pub fn changes(&self) -> i32 {
        unsafe { libwcdb_sys::WCDBHandleGetChange(self.as_ptr()) }
    }

    /// The wrapper of `sqlite3_total_changes`.
    pub fn total_changes(&self) -> i32 {
        unsafe { libwcdb_sys::WCDBHandleGetTotalChange(self.as_ptr()) }
    }

    /// The wrapper of `sqlite3_last_insert_rowid`.
    pub fn last_insert_rowid(&self) -> i64 {
        unsafe { libwcdb_sys::WCDBHandleGetLastInsertedRowID(self.as_ptr()) }
    }

    pub fn error(&self) -> error::Error {
        let err = unsafe { libwcdb_sys::WCDBHandleGetError(self.as_ptr()) };
        let wcdb_error = Box::new(WCDBError::from(err));
        wcdb_error.into()
    }
}

// main statement
impl Handle {
    pub fn get_main_stmt(&self) -> CPPHandleStatement {
        unsafe { libwcdb_sys::WCDBHandleGetMainStatement(self.as_ptr()) }
    }

    pub fn prepare(&self, stmt: &dyn Statement) -> Result<()> {
        let prepared = unsafe {
            libwcdb_sys::WCDBHandleStatementPrepare(self.get_main_stmt(), stmt.raw_stmt())
        };
        if !prepared {
            let err = unsafe { libwcdb_sys::WCDBHandleStatementGetError(self.get_main_stmt()) };
            let wcdb_error = Box::new(WCDBError::from(err));
            return Err(wcdb_error.into());
        }
        Ok(())
    }

    pub fn is_prepared(&self) -> bool {
        unsafe { libwcdb_sys::WCDBHandleStatementCheckPrepared(self.get_main_stmt()) }
    }
}

// Cancellation Signal

cpp_bridged!(pub struct CancellationSignal(libwcdb_sys::CPPCancellationSignal));

impl CancellationSignal {
    pub fn new() -> Self {
        let signal = unsafe { libwcdb_sys::WCDBCancellationSignalCreate() };
        signal.into()
    }

    /// Cancel all operations of the attached handle.
    pub fn cancel(&self) {
        unsafe {
            libwcdb_sys::WCDBCancellationSignalCancel(self.0);
        }
    }

    fn as_ptr(&self) -> libwcdb_sys::CPPCancellationSignal {
        self.0
    }
}

impl Default for CancellationSignal {
    fn default() -> Self {
        Self::new()
    }
}

impl Handle {
    /// The wrapper of `sqlite3_progress_handler`.
    ///
    /// You can asynchronously cancel all operations on the current handle through `CancellationSignal`.
    ///
    ///     let signal = CancellatiionSignal()
    ///     DispatchQueue(label: "test").async {
    ///         let handle = database.getHandle()
    ///         handle.attach(cancellationSignal: signal)
    ///
    ///         // Do some time-consuming database operations.
    ///
    ///         handle.detachCancellationSignal()
    ///     }
    ///     signal.cancel()
    ///
    /// Note that you can use `CancellationSignal` in multiple threads,
    /// but you can only use the current handle in the thread that you got it.
    pub fn attach_cancellation_signal(&self, signal: &CancellationSignal) {
        unsafe {
            libwcdb_sys::WCDBHandleAttachCancellationSignal(self.as_ptr(), signal.as_ptr());
        }
    }

    /// Detach the attached `CancellationSignal`.
    /// `CancellationSignal` can be automatically detached when the current handle deconstruct.
    pub fn detach_cancellation_signal(&self) {
        unsafe {
            libwcdb_sys::WCDBHandleDettachCancellationSignal(self.as_ptr());
        }
    }
}
